<!doctype html>
<html lang="en">
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type" />
    <meta charset="UTF-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <title>TN-ITS Map Viewer</title>

    <!-- Common styles -->
    <link href="/common.css" rel="stylesheet" />

    <!-- Viewer-specific styles -->
    <link href="/viewer.css" rel="stylesheet" />

    <!-- Leaflet CSS -->
    <link
      crossorigin=""
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      rel="stylesheet" />
  </head>
  <body>
    <div class="header">
      <a class="logo" href="/">
        <img alt="NVDB - Nasjonal vegdatabank" src="/nvdb_logo.svg" />
      </a>
      <nav aria-label="Main navigation" class="main-nav">
        <a href="/">Home</a>
        <a href="/api-docs.html">API Docs</a>
        <a href="/browser.html">Browser</a>
        <a href="/viewer.html" aria-current="page">Viewer</a>
      </nav>
    </div>

    <div class="container">
      <div class="viewer-controls">
        <div class="file-upload-section">
          <h2>Load TN-ITS File</h2>
          <p>
            Select a TN-ITS XML file to visualize road segments on the map
            below.
          </p>
          <label class="sr-only" for="fileInput">Select TN-ITS XML file</label>
          <input
            accept=".xml"
            aria-describedby="file-size-hint"
            id="fileInput"
            type="file" />
          <div class="file-size-hint" id="file-size-hint">
            Maximum file size: 20 MB
          </div>
          <div
            aria-live="assertive"
            class="error-message"
            id="errorMessage"
            role="alert"></div>
        </div>

        <div class="metadata-section">
          <h2>Dataset Information</h2>
          <div aria-live="polite" id="metadata">
            <div class="metadata-empty">No file loaded</div>
          </div>
        </div>
      </div>
    </div>

    <div class="map-container">
      <div
        aria-label="Interactive road network map"
        id="map"
        role="application"></div>

      <!-- Search Box Overlay -->
      <div class="search-overlay" id="searchOverlay" style="display: none">
        <div class="search-container">
          <label for="searchInput" class="search-label">
            Find vegobjekt by ID
          </label>
          <div class="search-input-group">
            <input
              type="text"
              id="searchInput"
              class="search-input"
              placeholder="Enter vegobjekt ID"
              aria-describedby="searchError" />
            <button id="searchButton" class="search-button">Search</button>
          </div>
          <div
            id="searchError"
            class="search-error"
            role="alert"
            aria-live="polite"
            style="display: none"></div>
        </div>
      </div>
    </div>

    <!-- Leaflet JS -->
    <script
      crossorigin=""
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
      // Initialize the Leaflet map
      const map = L.map('map')
      // Add OpenStreetMap tiles
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors',
      }).addTo(map)
      // Set a default view over Norway (approximate center)
      map.setView([65.0, 15.0], 4)

      // Global configuration
      let appConfig = null

      // Fetch config on page load
      fetch('/config')
        .then((response) => response.json())
        .then((config) => {
          appConfig = config
        })
        .catch((error) => {
          console.error('Failed to load config:', error)
        })

      // Global index to map vegobjekt IDs to their polylines
      let featureIndex = new Map()

      // Event listener for file upload
      document
        .getElementById('fileInput')
        .addEventListener('change', function (event) {
          const file = event.target.files[0]
          const errorMessage = document.getElementById('errorMessage')

          // Hide previous error
          errorMessage.classList.remove('show')

          if (!file) {
            return
          }

          // Check file size (20 MB limit)
          const maxSize = 20 * 1024 * 1024 // 20 MB in bytes
          if (file.size > maxSize) {
            const sizeMB = (file.size / (1024 * 1024)).toFixed(2)
            errorMessage.textContent = `File too large (${sizeMB} MB). Maximum allowed size is 20 MB.`
            errorMessage.classList.add('show')
            event.target.value = '' // Clear the file input
            return
          }

          const reader = new FileReader()
          reader.onload = function (e) {
            const text = e.target.result
            parseAndDisplay(text)
          }
          reader.onerror = function () {
            errorMessage.textContent = 'Failed to read file. Please try again.'
            errorMessage.classList.add('show')
          }
          reader.readAsText(file)
        })

      // Strip namespace prefix from property names
      function stripNamespace(name) {
        // Handle URL-style namespaces (e.g., "http://inspire.ec.europa.eu/codelist/ConditionOfFacilityValue")
        const lastSlashIndex = name.lastIndexOf('/')
        if (lastSlashIndex !== -1) {
          return name.substring(lastSlashIndex + 1)
        }
        // Handle colon-style namespaces (e.g., "nvdb:property")
        const colonIndex = name.indexOf(':')
        return colonIndex !== -1 ? name.substring(colonIndex + 1) : name
      }

      // Copy text to clipboard with visual feedback
      function copyToClipboard(elementId) {
        const element = document.getElementById(elementId)
        if (!element) return

        const text = element.textContent
        navigator.clipboard
          .writeText(text)
          .then(() => {
            // Create temporary feedback message
            const feedback = document.createElement('span')
            feedback.className = 'copy-feedback'
            feedback.textContent = '✓ Copied!'
            element.parentElement.appendChild(feedback)

            // Remove feedback after 2 seconds
            setTimeout(() => {
              feedback.remove()
            }, 2000)
          })
          .catch((err) => {
            console.error('Failed to copy text: ', err)
            alert('Failed to copy to clipboard')
          })
      }

      // Parse the XML string and draw polylines on the map
      function parseAndDisplay(xmlText) {
        // Clear existing layers (except the tile layer)
        map.eachLayer((layer) => {
          if (!(layer instanceof L.TileLayer)) {
            map.removeLayer(layer)
          }
        })

        // Clear the feature index
        featureIndex.clear()

        const parser = new DOMParser()
        const xmlDoc = parser.parseFromString(xmlText, 'application/xml')
        const gmlNS = 'http://www.opengis.net/gml/3.2'
        const tnitsNS = 'http://spec.tn-its.eu/schemas/'
        const xlinkNS = 'http://www.w3.org/1999/xlink'

        // Extract metadata from document
        let nvdbType = null
        let datasetId = null
        let datasetCreationTime = null
        let exportType = null

        const datasetIdElems = xmlDoc.getElementsByTagNameNS(
          tnitsNS,
          'datasetId',
        )
        if (datasetIdElems.length > 0) {
          datasetId = datasetIdElems[0].textContent.trim()
          // Format: NVDB-TNITS-105-SpeedLimit_Snapshot_2025-09-26T10:30:00Z
          const match = datasetId.match(/NVDB-TNITS-(\d+)-/)
          if (match) {
            nvdbType = match[1]
          }
        }

        const creationTimeElems = xmlDoc.getElementsByTagNameNS(
          tnitsNS,
          'datasetCreationTime',
        )
        if (creationTimeElems.length > 0) {
          datasetCreationTime = creationTimeElems[0].textContent.trim()
        }

        const typeElems = xmlDoc.getElementsByTagNameNS(tnitsNS, 'type')
        if (typeElems.length > 0) {
          // The first 'type' element at document level is the export type
          const firstType = typeElems[0]
          if (firstType.parentNode.nodeName.includes('RoadFeatureDataset')) {
            exportType = firstType.textContent.trim()
          }
        }

        // Get all RoadFeature elements within the dataset
        const roadFeatures = xmlDoc.getElementsByTagNameNS(
          tnitsNS,
          'RoadFeature',
        )
        const polylines = []
        for (let i = 0; i < roadFeatures.length; i++) {
          const roadFeature = roadFeatures[i]

          // Get the vegobjekt ID
          let vegobjektId = null
          const idElems = roadFeature.getElementsByTagNameNS(tnitsNS, 'id')
          if (idElems.length > 0) {
            const roadFeatureId = idElems[0].getElementsByTagNameNS(
              tnitsNS,
              'RoadFeatureId',
            )[0]
            if (roadFeatureId) {
              const idValueElem = roadFeatureId.getElementsByTagNameNS(
                tnitsNS,
                'id',
              )[0]
              if (idValueElem) {
                vegobjektId = idValueElem.textContent.trim()
              }
            }
          }

          // Get the feature type
          let featureType = null
          const typeElems = roadFeature.getElementsByTagNameNS(tnitsNS, 'type')
          if (typeElems.length > 0) {
            const typeHref = typeElems[0].getAttributeNS(xlinkNS, 'href')
            if (typeHref) {
              // Extract the fragment after the #
              const hashIndex = typeHref.indexOf('#')
              if (hashIndex !== -1) {
                featureType = typeHref.substring(hashIndex + 1)
              }
            }
          }

          // Get all properties
          const properties = []
          const props = roadFeature.getElementsByTagNameNS(
            tnitsNS,
            'GenericRoadFeatureProperty',
          )
          for (let j = 0; j < props.length; j++) {
            const prop = props[j]
            const typeElems = prop.getElementsByTagNameNS(tnitsNS, 'type')
            const valueElems = prop.getElementsByTagNameNS(tnitsNS, 'value')

            if (typeElems.length > 0 && valueElems.length > 0) {
              const typeHref = typeElems[0].getAttributeNS(xlinkNS, 'href')
              let propertyType = typeHref
              // Extract the fragment after the # for better readability
              const hashIndex = typeHref.indexOf('#')
              if (hashIndex !== -1) {
                propertyType = typeHref.substring(hashIndex + 1)
              }
              const propertyValue = valueElems[0].textContent.trim()
              properties.push({ type: propertyType, value: propertyValue })
            }
          }

          // Get validity dates
          let validFrom = null
          let validTo = null
          const validFromElems = roadFeature.getElementsByTagNameNS(
            tnitsNS,
            'validFrom',
          )
          if (validFromElems.length > 0) {
            validFrom = validFromElems[0].textContent.trim()
          }
          const validToElems = roadFeature.getElementsByTagNameNS(
            tnitsNS,
            'validTo',
          )
          if (validToElems.length > 0) {
            validTo = validToElems[0].textContent.trim()
          }

          // Get update type
          let updateType = null
          const updateInfoElems = roadFeature.getElementsByTagNameNS(
            tnitsNS,
            'updateInfo',
          )
          if (updateInfoElems.length > 0) {
            const updateInfoTypeElems =
              updateInfoElems[0].getElementsByTagNameNS(tnitsNS, 'UpdateInfo')
            if (updateInfoTypeElems.length > 0) {
              const typeElems = updateInfoTypeElems[0].getElementsByTagNameNS(
                tnitsNS,
                'type',
              )
              if (typeElems.length > 0) {
                updateType = typeElems[0].textContent.trim()
              }
            }
          }

          // Extract all location references
          const openLRReferences = []
          const nvdbReferences = []

          const locationRefs = roadFeature.getElementsByTagNameNS(
            tnitsNS,
            'locationReference',
          )
          for (let j = 0; j < locationRefs.length; j++) {
            const locRef = locationRefs[j]

            // Check for OpenLR binary references
            const openLRElems = locRef.getElementsByTagNameNS(
              tnitsNS,
              'OpenLRLocationReference',
            )
            if (openLRElems.length > 0) {
              const base64Elems = openLRElems[0].getElementsByTagNameNS(
                tnitsNS,
                'base64String',
              )
              if (base64Elems.length > 0) {
                openLRReferences.push(base64Elems[0].textContent.trim())
              }
            }

            // Check for NVDB external references
            const externalRefElems = locRef.getElementsByTagNameNS(
              tnitsNS,
              'LocationByExternalReference',
            )
            if (externalRefElems.length > 0) {
              const predefinedElems =
                externalRefElems[0].getElementsByTagNameNS(
                  tnitsNS,
                  'predefinedLocationReference',
                )
              if (predefinedElems.length > 0) {
                const href = predefinedElems[0].getAttributeNS(xlinkNS, 'href')
                if (href) {
                  nvdbReferences.push(href)
                }
              }
            }
          }

          // Build popup content once for this road feature
          let popupContent = ''
          if (nvdbType !== null) {
            popupContent += '<b>NVDB Type:</b> ' + nvdbType
          }
          if (featureType !== null) {
            if (popupContent !== '') popupContent += '<br>'
            popupContent += '<b>Feature type:</b> ' + featureType
          }
          if (vegobjektId !== null) {
            if (popupContent !== '') popupContent += '<br>'
            popupContent += '<b>Vegobjekt ID:</b> ' + vegobjektId
            popupContent += '<br>'
            if (nvdbType !== null) {
              popupContent +=
                '<a href="' +
                (appConfig?.nvdbBaseUrl ||
                  'https://nvdbapiles.atlas.vegvesen.no') +
                '/uberiket/api/v1/vegobjekter/' +
                nvdbType +
                '/' +
                vegobjektId +
                '" target="_blank" rel="noopener noreferrer">Uberiket API</a> | '
            } else {
              popupContent +=
                '<a href="' +
                (appConfig?.nvdbBaseUrl ||
                  'https://nvdbapiles.atlas.vegvesen.no') +
                '/uberiket/api/v1/vegobjekt/id/' +
                vegobjektId +
                '" target="_blank" rel="noopener noreferrer">Uberiket API</a> | '
            }
            popupContent +=
              '<a href="' +
              (appConfig?.nvdbBaseUrl ||
                'https://nvdbapiles.atlas.vegvesen.no') +
              '/vegobjekt?id=' +
              vegobjektId +
              '" target="_blank" rel="noopener noreferrer">Vegobjekter API Les</a>'
            if (appConfig?.vegkartBaseUrl) {
              popupContent +=
                ' | <a href="' +
                appConfig.vegkartBaseUrl +
                '#valgt:' +
                vegobjektId +
                '" target="_blank" rel="noopener noreferrer">Vegkart</a>'
            }
          }
          if (properties.length > 0) {
            if (popupContent !== '') popupContent += '<br><br>'
            popupContent += '<b>Properties:</b><br>'
            properties.forEach((prop) => {
              popupContent +=
                '&nbsp;&nbsp;<b>' +
                stripNamespace(prop.type) +
                ':</b> ' +
                prop.value +
                '<br>'
            })
          }
          if (validFrom !== null || validTo !== null) {
            if (popupContent !== '') popupContent += '<br>'
            popupContent += '<b>Valid:</b> '
            if (validFrom !== null) {
              popupContent += validFrom
            }
            if (validTo !== null) {
              popupContent += ' → ' + validTo
            }
          }
          if (updateType !== null) {
            if (popupContent !== '') popupContent += '<br>'
            popupContent += '<b>Update type:</b> ' + updateType
          }
          if (openLRReferences.length > 0) {
            if (popupContent !== '') popupContent += '<br><br>'
            popupContent += '<b>OpenLR references:</b><br>'
            openLRReferences.forEach((ref, idx) => {
              const refId = 'openlr-' + i + '-' + idx
              popupContent += '<div class="openlr-container">'
              popupContent += '&nbsp;&nbsp;' + (idx + 1) + '. '
              popupContent +=
                '<span class="openlr-text" id="' +
                refId +
                '">' +
                ref +
                '</span>'
              popupContent +=
                '<button class="icon-button" onclick="copyToClipboard(\'' +
                refId +
                '\')" title="Copy to clipboard">Copy</button>'
              popupContent += '</div>'
            })
            popupContent +=
              '<div style="margin-top: 8px; margin-left: 16px;"><a href="https://demo.tomtom.com" target="_blank" rel="noopener noreferrer">Verify on TomTom</a></div>'
          }
          if (nvdbReferences.length > 0) {
            if (popupContent !== '') popupContent += '<br><br>'
            popupContent += '<b>NVDB references:</b><br>'
            nvdbReferences.forEach((ref, idx) => {
              popupContent +=
                '&nbsp;&nbsp;' +
                (idx + 1) +
                '. <span class="popup-reference">' +
                ref +
                '</span><br>'
            })
          }

          // Get all gml:posList elements (may be multiple per RoadFeature)
          const posListElems = roadFeature.getElementsByTagNameNS(
            gmlNS,
            'posList',
          )
          if (posListElems.length === 0) continue

          // Create a polyline for each LineString geometry
          for (let j = 0; j < posListElems.length; j++) {
            const coordsString = posListElems[j].textContent.trim()
            const coordsArray = coordsString.split(/\s+/).map(parseFloat)
            const latLngs = []
            for (let k = 0; k < coordsArray.length; k += 2) {
              const lat = coordsArray[k]
              const lon = coordsArray[k + 1]
              if (!isNaN(lat) && !isNaN(lon)) {
                latLngs.push([lat, lon])
              }
            }
            if (latLngs.length > 0) {
              const polyline = L.polyline(latLngs, {
                color: '#3b82f6',
                weight: 4,
                opacity: 0.8,
              })
              if (popupContent !== '') {
                polyline.bindPopup(popupContent, {
                  maxWidth: 400,
                })
              }
              polylines.push(polyline)

              // Store in feature index if we have a vegobjekt ID
              if (vegobjektId !== null) {
                if (!featureIndex.has(vegobjektId)) {
                  featureIndex.set(vegobjektId, [])
                }
                featureIndex.get(vegobjektId).push(polyline)
              }
            }
          }
        }
        // Add all polylines to map and fit bounds
        if (polylines.length > 0) {
          const group = L.featureGroup(polylines).addTo(map)
          map.fitBounds(group.getBounds())
        } else {
          alert('No geometry found in the XML file.')
        }

        // Update metadata display in header
        const metadataDiv = document.getElementById('metadata')
        let metadataHtml = ''
        if (nvdbType !== null) {
          metadataHtml +=
            '<div><span class="metadata-label">NVDB Type:</span> <span class="metadata-value">' +
            nvdbType +
            '</span></div>'
        }
        if (exportType !== null) {
          metadataHtml +=
            '<div><span class="metadata-label">Export Type:</span> <span class="metadata-value">' +
            exportType +
            '</span></div>'
        }
        if (datasetCreationTime !== null) {
          metadataHtml +=
            '<div><span class="metadata-label">Created:</span> <span class="metadata-value">' +
            datasetCreationTime +
            '</span></div>'
        }
        metadataHtml +=
          '<div><span class="metadata-label">Features:</span> <span class="metadata-value">' +
          roadFeatures.length +
          '</span></div>'
        if (datasetId !== null) {
          metadataHtml +=
            '<div><span class="metadata-label">Dataset ID:</span> <span class="metadata-value">' +
            datasetId +
            '</span></div>'
        }
        metadataDiv.innerHTML = metadataHtml

        // Show the search overlay
        document.getElementById('searchOverlay').style.display = 'block'
      }

      // Search for a vegobjekt by ID
      function searchVegobjekt() {
        const searchInput = document.getElementById('searchInput')
        const searchError = document.getElementById('searchError')
        const searchId = searchInput.value.trim()

        // Hide previous error
        searchError.style.display = 'none'

        if (!searchId) {
          searchError.textContent = 'Please enter a vegobjekt ID'
          searchError.style.display = 'block'
          return
        }

        // Look up the feature in the index
        if (featureIndex.has(searchId)) {
          const polylines = featureIndex.get(searchId)

          // Create a feature group to get bounds
          const group = L.featureGroup(polylines)
          map.fitBounds(group.getBounds(), {
            padding: [50, 50],
            maxZoom: 16,
          })

          // Open the popup on the first polyline
          if (polylines[0].getPopup()) {
            polylines[0].openPopup()
          }
        } else {
          searchError.textContent = `No feature found with ID: ${searchId}`
          searchError.style.display = 'block'
        }
      }

      // Event listeners for search functionality
      document
        .getElementById('searchButton')
        .addEventListener('click', searchVegobjekt)

      document
        .getElementById('searchInput')
        .addEventListener('keypress', function (e) {
          if (e.key === 'Enter') {
            searchVegobjekt()
          }
        })

      document
        .getElementById('searchInput')
        .addEventListener('input', function () {
          // Clear error message when input changes
          document.getElementById('searchError').style.display = 'none'
        })
    </script>
  </body>
</html>
