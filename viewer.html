<html lang="en">
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="content-type"/>
  <meta charset="UTF-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>TN-ITS Map Viewer</title>
  <!-- Leaflet CSS -->
  <link
    crossorigin=""
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    rel="stylesheet"
  />
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
    }

    body {
      display: flex;
      flex-direction: column;
    }

    .content {
      padding: 1rem;
      flex-shrink: 0;
      display: flex;
      gap: 2rem;
      align-items: flex-start;
    }

    .left-section {
      flex: 0 0 auto;
    }

    .metadata-section {
      flex: 1;
      font-size: 0.9rem;
      color: #555;
      line-height: 1.6;
    }

    header {
      font-size: 1.2rem;
      font-weight: bold;
      margin-bottom: 0.5rem;
    }

    .metadata-label {
      font-weight: bold;
      color: #333;
    }

    input[type='file'] {
      margin-top: 0.5rem;
    }

    #map {
      flex: 1;
      width: 100%;
      min-height: 0;
    }

    .popup-reference {
      white-space: nowrap;
    }

    .openlr-container {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 4px 0;
    }

    .openlr-text {
      font-family: monospace;
      word-break: break-all;
      flex: 1;
    }

    .icon-button {
      cursor: pointer;
      padding: 2px 6px;
      border: 1px solid #ccc;
      border-radius: 3px;
      background: #f5f5f5;
      font-size: 14px;
      transition: background 0.2s;
      text-decoration: none;
      display: inline-block;
    }

    .icon-button:hover {
      background: #e0e0e0;
    }

    .icon-button:active {
      background: #d0d0d0;
    }

    .copy-feedback {
      color: #4CAF50;
      font-size: 12px;
      margin-left: 8px;
    }
  </style>
</head>
<body>
<div class="content">
  <div class="left-section">
    <header>TN-ITS Map Viewer</header>
    <p>
      Select a TN-ITS XML file to visualize the road segments on
      a map.
    </p>
    <input accept=".xml" id="fileInput" type="file"/>
  </div>
  <div class="metadata-section" id="metadata">
    <em>No file loaded</em>
  </div>
</div>
<div id="map"></div>

<!-- Leaflet JS -->
<script
  crossorigin=""
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
></script>
<script>
  // Initialize the Leaflet map
  const map = L.map('map')
  // Add OpenStreetMap tiles
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; OpenStreetMap contributors',
  }).addTo(map)
  // Set a default view over Norway (approximate center)
  map.setView([65.0, 15.0], 4)

  // Event listener for file upload
  document
    .getElementById('fileInput')
    .addEventListener('change', function (event) {
      const file = event.target.files[0]
      if (!file) {
        return
      }
      const reader = new FileReader()
      reader.onload = function (e) {
        const text = e.target.result
        parseAndDisplay(text)
      }
      reader.readAsText(file)
    })

  // Copy text to clipboard with visual feedback
  function copyToClipboard(elementId) {
    const element = document.getElementById(elementId)
    if (!element) return

    const text = element.textContent
    navigator.clipboard.writeText(text).then(() => {
      // Create temporary feedback message
      const feedback = document.createElement('span')
      feedback.className = 'copy-feedback'
      feedback.textContent = '✓ Copied!'
      element.parentElement.appendChild(feedback)

      // Remove feedback after 2 seconds
      setTimeout(() => {
        feedback.remove()
      }, 2000)
    }).catch(err => {
      console.error('Failed to copy text: ', err)
      alert('Failed to copy to clipboard')
    })
  }

  // Parse the XML string and draw polylines on the map
  function parseAndDisplay(xmlText) {
    // Clear existing layers (except the tile layer)
    map.eachLayer((layer) => {
      if (!(layer instanceof L.TileLayer)) {
        map.removeLayer(layer)
      }
    })
    const parser = new DOMParser()
    const xmlDoc = parser.parseFromString(xmlText, 'application/xml')
    const gmlNS = 'http://www.opengis.net/gml/3.2'
    const tnitsNS = 'http://spec.tn-its.eu/schemas/'
    const xlinkNS = 'http://www.w3.org/1999/xlink'

    // Extract metadata from document
    let nvdbType = null
    let datasetId = null
    let datasetCreationTime = null
    let exportType = null

    const datasetIdElems = xmlDoc.getElementsByTagNameNS(tnitsNS, 'datasetId')
    if (datasetIdElems.length > 0) {
      datasetId = datasetIdElems[0].textContent.trim()
      // Format: NVDB-TNITS-105-SpeedLimit_Snapshot_2025-09-26T10:30:00Z
      const match = datasetId.match(/NVDB-TNITS-(\d+)-/)
      if (match) {
        nvdbType = match[1]
      }
    }

    const creationTimeElems = xmlDoc.getElementsByTagNameNS(tnitsNS, 'datasetCreationTime')
    if (creationTimeElems.length > 0) {
      datasetCreationTime = creationTimeElems[0].textContent.trim()
    }

    const typeElems = xmlDoc.getElementsByTagNameNS(tnitsNS, 'type')
    if (typeElems.length > 0) {
      // The first 'type' element at document level is the export type
      const firstType = typeElems[0]
      if (firstType.parentNode.nodeName.includes('RoadFeatureDataset')) {
        exportType = firstType.textContent.trim()
      }
    }

    // Get all RoadFeature elements within the dataset
    const roadFeatures = xmlDoc.getElementsByTagNameNS(
      tnitsNS,
      'RoadFeature'
    )
    const polylines = []
    for (let i = 0; i < roadFeatures.length; i++) {
      const roadFeature = roadFeatures[i]

      // Get the vegobjekt ID
      let vegobjektId = null
      const idElems = roadFeature.getElementsByTagNameNS(tnitsNS, 'id')
      if (idElems.length > 0) {
        const roadFeatureId = idElems[0].getElementsByTagNameNS(
          tnitsNS,
          'RoadFeatureId'
        )[0]
        if (roadFeatureId) {
          const idValueElem = roadFeatureId.getElementsByTagNameNS(
            tnitsNS,
            'id'
          )[0]
          if (idValueElem) {
            vegobjektId = idValueElem.textContent.trim()
          }
        }
      }

      // Get the feature type
      let featureType = null
      const typeElems = roadFeature.getElementsByTagNameNS(tnitsNS, 'type')
      if (typeElems.length > 0) {
        const typeHref = typeElems[0].getAttributeNS(xlinkNS, 'href')
        if (typeHref) {
          // Extract the fragment after the #
          const hashIndex = typeHref.indexOf('#')
          if (hashIndex !== -1) {
            featureType = typeHref.substring(hashIndex + 1)
          }
        }
      }

      // Get all properties
      const properties = []
      const props = roadFeature.getElementsByTagNameNS(
        tnitsNS,
        'GenericRoadFeatureProperty'
      )
      for (let j = 0; j < props.length; j++) {
        const prop = props[j]
        const typeElems = prop.getElementsByTagNameNS(tnitsNS, 'type')
        const valueElems = prop.getElementsByTagNameNS(tnitsNS, 'value')

        if (typeElems.length > 0 && valueElems.length > 0) {
          const typeHref = typeElems[0].getAttributeNS(xlinkNS, 'href')
          let propertyType = typeHref
          // Extract the fragment after the # for better readability
          const hashIndex = typeHref.indexOf('#')
          if (hashIndex !== -1) {
            propertyType = typeHref.substring(hashIndex + 1)
          }
          const propertyValue = valueElems[0].textContent.trim()
          properties.push({type: propertyType, value: propertyValue})
        }
      }

      // Get validity dates
      let validFrom = null
      let validTo = null
      const validFromElems = roadFeature.getElementsByTagNameNS(tnitsNS, 'validFrom')
      if (validFromElems.length > 0) {
        validFrom = validFromElems[0].textContent.trim()
      }
      const validToElems = roadFeature.getElementsByTagNameNS(tnitsNS, 'validTo')
      if (validToElems.length > 0) {
        validTo = validToElems[0].textContent.trim()
      }

      // Get update type
      let updateType = null
      const updateInfoElems = roadFeature.getElementsByTagNameNS(tnitsNS, 'updateInfo')
      if (updateInfoElems.length > 0) {
        const updateInfoTypeElems = updateInfoElems[0].getElementsByTagNameNS(tnitsNS, 'UpdateInfo')
        if (updateInfoTypeElems.length > 0) {
          const typeElems = updateInfoTypeElems[0].getElementsByTagNameNS(tnitsNS, 'type')
          if (typeElems.length > 0) {
            updateType = typeElems[0].textContent.trim()
          }
        }
      }

      // Extract all location references
      const openLRReferences = []
      const nvdbReferences = []

      const locationRefs = roadFeature.getElementsByTagNameNS(tnitsNS, 'locationReference')
      for (let j = 0; j < locationRefs.length; j++) {
        const locRef = locationRefs[j]

        // Check for OpenLR binary references
        const openLRElems = locRef.getElementsByTagNameNS(tnitsNS, 'OpenLRLocationReference')
        if (openLRElems.length > 0) {
          const base64Elems = openLRElems[0].getElementsByTagNameNS(tnitsNS, 'base64String')
          if (base64Elems.length > 0) {
            openLRReferences.push(base64Elems[0].textContent.trim())
          }
        }

        // Check for NVDB external references
        const externalRefElems = locRef.getElementsByTagNameNS(tnitsNS, 'LocationByExternalReference')
        if (externalRefElems.length > 0) {
          const predefinedElems = externalRefElems[0].getElementsByTagNameNS(tnitsNS, 'predefinedLocationReference')
          if (predefinedElems.length > 0) {
            const href = predefinedElems[0].getAttributeNS(xlinkNS, 'href')
            if (href) {
              nvdbReferences.push(href)
            }
          }
        }
      }

      // Build popup content once for this road feature
      let popupContent = ''
      if (nvdbType !== null) {
        popupContent += '<b>NVDB Type:</b> ' + nvdbType
      }
      if (featureType !== null) {
        if (popupContent !== '') popupContent += '<br>'
        popupContent += '<b>Feature type:</b> ' + featureType
      }
      if (vegobjektId !== null) {
        if (popupContent !== '') popupContent += '<br>'
        popupContent += '<b>Vegobjekt ID:</b> ' + vegobjektId
        popupContent += '<br>'
        if (nvdbType !== null) {
          popupContent += '<a href="https://nvdbapiles.atlas.vegvesen.no/uberiket/api/v1/vegobjekter/' + nvdbType + '/' + vegobjektId + '" target="_blank">Uberiket API</a> | '
        } else {
          popupContent += '<a href="https://nvdbapiles.atlas.vegvesen.no/uberiket/api/v1/vegobjekt/id/' + vegobjektId + '" target="_blank">Uberiket API</a> | '
        }
        popupContent += '<a href="https://nvdbapiles.atlas.vegvesen.no/vegobjekt?id=' + vegobjektId + '" target="_blank">Vegobjekter API Les</a>'
      }
      if (properties.length > 0) {
        if (popupContent !== '') popupContent += '<br><br>'
        popupContent += '<b>Properties:</b><br>'
        properties.forEach((prop) => {
          popupContent += '&nbsp;&nbsp;<b>' + prop.type + ':</b> ' + prop.value + '<br>'
        })
      }
      if (validFrom !== null || validTo !== null) {
        if (popupContent !== '') popupContent += '<br>'
        popupContent += '<b>Valid:</b> '
        if (validFrom !== null) {
          popupContent += validFrom
        }
        if (validTo !== null) {
          popupContent += ' → ' + validTo
        }
      }
      if (updateType !== null) {
        if (popupContent !== '') popupContent += '<br>'
        popupContent += '<b>Update type:</b> ' + updateType
      }
      if (openLRReferences.length > 0) {
        if (popupContent !== '') popupContent += '<br><br>'
        popupContent += '<b>OpenLR references:</b><br>'
        openLRReferences.forEach((ref, idx) => {
          const refId = 'openlr-' + i + '-' + idx
          popupContent += '<div class="openlr-container">'
          popupContent += '&nbsp;&nbsp;' + (idx + 1) + '. '
          popupContent += '<span class="openlr-text" id="' + refId + '">' + ref + '</span>'
          popupContent += '<button class="icon-button" onclick="copyToClipboard(\'' + refId + '\')" title="Copy to clipboard">Copy</button>'
          popupContent += '</div>'
        })
        popupContent += '<div style="margin-top: 8px; margin-left: 16px;"><a href="https://demo.tomtom.com" target="_blank">Verify on TomTom</a></div>'
      }
      if (nvdbReferences.length > 0) {
        if (popupContent !== '') popupContent += '<br><br>'
        popupContent += '<b>NVDB references:</b><br>'
        nvdbReferences.forEach((ref, idx) => {
          popupContent += '&nbsp;&nbsp;' + (idx + 1) + '. <span class="popup-reference">' + ref + '</span><br>'
        })
      }

      // Get all gml:posList elements (may be multiple per RoadFeature)
      const posListElems = roadFeature.getElementsByTagNameNS(
        gmlNS,
        'posList'
      )
      if (posListElems.length === 0) continue

      // Create a polyline for each LineString geometry
      for (let j = 0; j < posListElems.length; j++) {
        const coordsString = posListElems[j].textContent.trim()
        const coordsArray = coordsString.split(/\s+/).map(parseFloat)
        const latLngs = []
        for (let k = 0; k < coordsArray.length; k += 2) {
          const lat = coordsArray[k]
          const lon = coordsArray[k + 1]
          if (!isNaN(lat) && !isNaN(lon)) {
            latLngs.push([lat, lon])
          }
        }
        if (latLngs.length > 0) {
          const polyline = L.polyline(latLngs, {
            color: '#3388ff',
            weight: 4,
            opacity: 0.8,
          })
          if (popupContent !== '') {
            polyline.bindPopup(popupContent)
          }
          polylines.push(polyline)
        }
      }
    }
    // Add all polylines to map and fit bounds
    if (polylines.length > 0) {
      const group = L.featureGroup(polylines).addTo(map)
      map.fitBounds(group.getBounds())
    } else {
      alert('No geometry found in the XML file.')
    }

    // Update metadata display in header
    const metadataDiv = document.getElementById('metadata')
    let metadataHtml = ''
    if (nvdbType !== null) {
      metadataHtml += '<div><span class="metadata-label">NVDB Type:</span> ' + nvdbType + '</div>'
    }
    if (exportType !== null) {
      metadataHtml += '<div><span class="metadata-label">Export Type:</span> ' + exportType + '</div>'
    }
    if (datasetCreationTime !== null) {
      metadataHtml += '<div><span class="metadata-label">Created:</span> ' + datasetCreationTime + '</div>'
    }
    metadataHtml += '<div><span class="metadata-label">Features:</span> ' + roadFeatures.length + '</div>'
    if (datasetId !== null) {
      metadataHtml += '<div><span class="metadata-label">Dataset ID:</span> ' + datasetId + '</div>'
    }
    metadataDiv.innerHTML = metadataHtml
  }
</script>
</body>
</html>
